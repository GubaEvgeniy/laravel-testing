## О проекте

Данный проект был создан как пример моей разработки приложения. Code review приветствуется и пойдет на пользу!

Так же для реализации данного приложения, были использованы такие возможности фреймворка laravel(не только фреймворка) как events, console commands, scopes, providers, validation requests, blade views, phpunit
Ниже я постараюсь дать подробное описание компонентов приложения, с его минусами и плюсами.

## Docker
Мне нравится использовать докер, т.к. он предоставляет возможности изолированости кода и запуска проекта без настройки сервера.
Из интересного: 
* При запуске контейнера из образа пользователь www-data получает uid и gid, которые будут переданы извне. Когда мы зайдем в контейнер, и создадим, например, файл миграции, то на машине хоста владельцем этого файла будем не мы. И каждый раз надо будет менять права созданного файла
* Установка xDebug. Возможно в современном вебе использованием xDebug кого и не удивить, т.к. по факту это должно быть стандартом разработки. Однако мне необходимо было отобразить его использование мною
* Использование Makefile и команды `make` для более быстрого доступа к контейнерам и быстрый доступ к наиболее используемым командам
  
## Laravel

* Для упрощения разработки использовал пакет [barryvdh/laravel-ide-helper](https://github.com/barryvdh/laravel-ide-helper). Он позволяет генерировать вспомогательные файлы(например для фасадов или моделей), которые позволяют IDE использовать более точное автозаполнение 
* Для Front-части установка отдельного контейнера с nodeJS и использование пакета `laravel-mix` для упрощения работы с конвертацией `scss` в обычный `css` и прочее
* Использование `laravel-ui` для быстрой генерации дефолтной системы аутентификации
 
## Описание приложения

Данное проект представляет собой веб-приложение для розыгрыша призов(benefits). После аутентификации пользователь может нажать на кнопку и получить случайный приз. 
Призы бывают 3х типов: 
 * денежный приз (случайная сумма в интервале). Денежный приз может быть перечислен на счет пользователя в банке (HTTP запрос к API банка). Может конвертироваться в баллы лояльности с учетом коэффициента
 * бонусные баллы (случайная сумма в интервале). Баллы могут быть зачислены на счет лояльности в приложении
 * физический предмет (случайный предмет из списка). Может быть отправлен по почте (вручную работником). Денежный приз может .
От приза можно отказаться. Деньги и предметы ограничены, баллы лояльности нет.

## Реализация
### Benefits
Каждый приз реализован как отдельный класс со своими свойствами подсчёта выигрыша. Для денег это рандомное число из диапозона, для реального предмета это случайное имя из списка имен.
Данные о размере диапозона и список имен реальных предметов, хранится в базе в таблице `benefits`. Таким образом в будущем, мы можем легко внести изменения в приз, а так же повесить на него необходимые настройки - например ограничение на количество выигравших.
За взаимодействие с призами отвечае класс `BenefitsServices`, который впрочем не знает какие в данный момент призы вообще существуют - он работает с одним интерфейсом `BenefitsTypeInterfaceё`, который сам реализует необходимые призы. Таким образом если нам понадобится сделать добавление нового приза, не нужно будет делать изменения в коде - достаточно создать новый приз и имплементировать его данным интерфейсом
При выпадении приза, происходит запись в таблицу `users_benefits`. С помощью этой записи мы можем:
* понять какой приз, с каким результатом, какому юзеры выпал
* посмотреть данные о условиях приза(если в будущем эти условия поменялись)
* можно построить историю выпадения призов для юзера
* можно отследить использовал ли юзер выпавший ему приз или полностью отказался от него

### Withdrawal Real Items
Если юзер принимает приз реальный предмет, тогда создаётся запись в таблице `withdrawal_items`, в которой можно увидеть процесс этой отправки.
Условный менеджер теперь может контролировать процесс отправки.

### Billing
Для взаимодействия с денежным призом, мною была реализована условно абстрактная биллинг система. Суть её заключается в том, что у пользователя есть два кошелька - `bonus_money` и `real_money`.
Для сохранения консистентность данных, используется таблица `billing_transactions` в которой отображены все транзакции по любому из кошельков:
 * добавление денег будь-то из приза или каких-либо других источников, которые могут возникнуть в будущем,
 * или списание средств, при конвертации бонусных денег в реальные, или вывод реальных денег на карту пользователя
 
На момент написания readme, в данной системе нехватает реализации блокировок на саму транзакцию - имеется ввиду, что б не могла возникнуть ситация, когда взаимодействие с кошельком происходит в один и тот же момент времени в разных ситуациях. Абстрактный пример: мы делаем конвертацию с бонусного счета в реальный и при этом покупаем за бонусные деньги реальный предмет. Такие запросы должны происходит последовательно, с учётом состоянии гонки 

### PaymentSystem
Реализовано путём создания простого класса с одним методом `paymentTransfer`, который делает запрос с API банка с необходимыми нам параметрами.
По факту данное действие должно быть реализованно путём использования очереди, например через Redis. Т.е. что б юзер при выводе средств, не ждал пока этот запрос (к api банка) отпработает и вернет какой-то результат. Для разруливание данной ситуации в `billing_transactions` должно быть добавленна колонка `status` которая и отображала б процесс данной транзакции. Для вывода на счет пользователя данная транзакция была бы в статусе `open` при запросе к банку и меняла свой статус в зависимости от webhook`a на которой банк дал бы свой ответ по данной транзакции 

## В заключении
Реализации данного проекта писалась на ограниченное количество времени, было потрачено ~2 рабочих дня. Тут полноценности приложения тут недостаёт некоторых решений, однако свою цель - абстрактно показать пример моего кода он полностью выполняет.
Буду крайне благодарен за критику и отзывы! 
